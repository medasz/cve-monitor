package crawlers

import (
	"context"
	"fmt"
	"log"
	"strings"
	"time"

	"github-cve/db/db_exploit"
	"github-cve/db/db_vulnerability"
	"github-cve/model/exploit"

	"github.com/PuerkitoBio/goquery"
	"github.com/chromedp/chromedp"
)

type ExploitDB struct {
	result string
}

func (receiver *ExploitDB) Run() {
	for true {
		db_vulnerability.GetItems(receiver.SearchCve)
	}
}

func (receiver *ExploitDB) SearchCve(info db_vulnerability.CveInfo) {
	options := []chromedp.ExecAllocatorOption{
		chromedp.Flag("headless", true),
	}
	options = append(chromedp.DefaultExecAllocatorOptions[:], options...)

	ctx, _ := chromedp.NewExecAllocator(context.Background(), options...)
	ctx, cancel := chromedp.NewContext(ctx)
	defer cancel()

	err := chromedp.Run(ctx,
		chromedp.Tasks{
			chromedp.Navigate("https://www.exploit-db.com/"),
			chromedp.WaitReady(`#cveSearch`, chromedp.ByQuery),
			chromedp.SetValue(`#cveSearch`, info.CveId, chromedp.ByQuery),
			chromedp.Submit(`#searchForm > div:nth-child(5) > div > button`, chromedp.ByQuery),
			chromedp.WaitNotVisible(`#exploits-table_processing`, chromedp.ByQuery),
			chromedp.OuterHTML(`html`, &receiver.result, chromedp.ByQuery),
		},
	)
	if err != nil {
		return
	}
	receiver.GetExploitInfo(info.Id)

	for receiver.CheckNext(receiver.result) {
		err := chromedp.Run(ctx, chromedp.Tasks{
			chromedp.Click("#exploits-table_next > a", chromedp.ByQuery),
			chromedp.WaitNotVisible("#exploits-table_processing", chromedp.ByQuery),
			chromedp.OuterHTML("html", &receiver.result, chromedp.ByQuery),
		})
		if err != nil {
			log.Println(err)
			continue
		}
		receiver.GetExploitInfo(info.Id)
	}

}

func (receiver *ExploitDB) CheckNext(result string) bool {
	doc, err := goquery.NewDocumentFromReader(strings.NewReader(result))
	if err != nil {
		log.Println(err)
		return false
	}
	return !doc.Find("#exploits-table_next").HasClass("disabled")
}

func (receiver *ExploitDB) GetExploitInfo(vulnerabilityID uint) error {
	doc, err := goquery.NewDocumentFromReader(strings.NewReader(receiver.result))
	if err != nil {
		return err
	}
	doc.Find("#exploits-table > tbody > tr").Each(func(i int, selection *goquery.Selection) {
		fmt.Println(selection.Text())
		data := new(exploit.Exploit)
		selection.Find("td").Each(func(i int, selection *goquery.Selection) {
			switch i {
			case 0:
				data.Date, _ = time.ParseInLocation("2006-01-02", selection.Text(), time.Local)
			case 1:
				href, exists := selection.Find("a").Attr("href")
				if exists {
					data.DownloadExploit = fmt.Sprintf("https://www.exploit-db.com%s", href)
				}
			case 2:
				href, exists := selection.Find("a").Attr("href")
				if exists {
					data.VulnerableApplicationLink = fmt.Sprintf("https://www.exploit-db.com%s", href)
				}
			case 3:
				data.Verified = !selection.Find("i").HasClass("mdi-close")

			case 4:
				data.Title = selection.Find("a").Text()
				href, exists := selection.Find("a").Attr("href")
				if exists {
					data.TitleLink = fmt.Sprintf("https://www.exploit-db.com%s", href)
				}
			case 5:
				data.Type = selection.Text()
			case 6:
				data.Platform = selection.Text()
			case 7:
				data.Author = selection.Text()
			}
		})
		data.VulnerabilityID = vulnerabilityID
		fmt.Println(data)
		res, _ := db_exploit.GetItemByVulnerabilityId(vulnerabilityID)
		if data.Title == "" {
			return
		}

		db_exploit.FirstOrCreate(data)
		if res != nil && len(res) > 0 {
			var flag bool
			for _, tmp := range res {
				if tmp.ID == data.ID {
					flag = true
				}
			}
			if !flag {
				db_exploit.DeleteItemsByVulnerabilityId(res)
			}
		}
	})
	return nil
}
